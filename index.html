<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
</head>

<body>
  <a-scene
    vr-mode-ui="enabled: false;"
    renderer="logarithmicDepthBuffer: true;"
    embedded
    arjs="trackingMethod: best; sourceType: webcam;debugUIEnabled: false;"
  >        <!-- url链接要改 -->
        <a-nft
            type="nft"
            url="https://quaaron.github.io/webar.github.io/chinaCenter/chinaCenter"
            smooth="true"
            smoothCount="10"
            smoothTolerance=".01"
            smoothThreshold="5">            
            <a-entity rate-curve position="-1 1 -5" rotation="80 45 0"></a-entity>
            <a-entity position="10 0 10" rotation="0 50 0">
                <a-camera></a-camera>
            </a-entity>
            <a-light type="ambient" color="#445"></a-light>
            <a-light type="directional" color="#fff" position="2 4 -4"></a-light>

            <!-- XYZ轴 -->
            <a-box position="-2.5 0 -2" depth="0.05" height="0.05" width="10" color="red"></a-box>
            <a-box position="-5 2.5 -2" depth="0.05" height="10" width="0.05" color="green"></a-box>
            <a-box position="-5 0 0.5" depth="10" height="0.05" width="0.05" color="blue" rotation="0 0 90"></a-box>

            <!-- 坐标title -->
            <a-text value="Date" color="red" position="4 0 -2"></a-text>
            <a-text value="Type" color="green" position="-5 8 -2"></a-text>
            <a-text value="ratio" color="blue" position="-5 0 6"></a-text>

            <a-entity camera="fov: 190"></a-entity>
        </a-nft>
    </a-scene>

    <script>
        AFRAME.registerComponent('rate-curve', {
            schema: {
                interval: { type: 'number', default: 3000 } // 时间间隔以毫秒为单位
            },
            init: function () {
                var sceneEl = this.el.sceneEl;
                var scene = sceneEl.object3D;

                // Curve
                var curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(-2, 2, 0),
                    new THREE.Vector3(-1, 0.5, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(1, 3, 0),
                    new THREE.Vector3(2, 1, 0)
                ]);

                var pointsCount = 50;
                var pointsCount1 = pointsCount + 1;
                var pts = curve.getPoints(pointsCount);
                var width = 2;
                let pts2 = curve.getPoints(pointsCount);
                pts2.forEach(p => p.z += width);
                pts = pts.concat(pts2);

                var ribbonGeom = new THREE.BufferGeometry().setFromPoints(pts);
                var indices = [];
                for (let iy = 0; iy < 1; iy++) {
                    for (let ix = 0; ix < pointsCount; ix++) {
                        var a = ix + pointsCount1 * iy;
                        var b = ix + pointsCount1 * (iy + 1);
                        var c = (ix + 1) + pointsCount1 * (iy + 1);
                        var d = (ix + 1) + pointsCount1 * iy;

                        indices.push(a, b, d);
                        indices.push(b, c, d);
                    }
                }
                ribbonGeom.setIndex(indices);
                ribbonGeom.computeVertexNormals();

                var ribbon = new THREE.Mesh(ribbonGeom, new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }));
                scene.add(ribbon);

                // Line
                var line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(curve.getPoints(pointsCount)), new THREE.LineBasicMaterial({ color: "red", depthTest: false }));
                scene.add(line);
                this.ribbon = ribbon;
                this.curve = curve;
            },
            tick: function (time, timeDelta) {
                if (time - this.lastTime < this.data.interval) {
                    return; // 如果没有达到指定间隔，什么都不做
                }
                this.lastTime = time; // 更新上次执行时间
                // 根据时间更新曲线的顶点数值
                var curve = this.curve;
                let newPoints = []
                for (let i = 1; i < 50; i++) {
                    newPoints.push(new THREE.Vector3(-3 + 0.2 * i, 1.65 + Math.random() * (3.85 - 3.65), 0))
                }
                curve.points = newPoints;

                // 重新生成曲线的几何体
                var ribbonGeom = this.ribbon.geometry;
                var points = curve.getPoints(50);
                let points2 = curve.getPoints(50);
                let width = 2;
                points2.forEach(p => p.z += width);
                var pts = points.concat(points2);

                ribbonGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pts.flatMap(p => [p.x, p.y, p.z])), 3));
                ribbonGeom.attributes.position.needsUpdate = true;
                console.log(this.ribbon.rotation.x)
                this.ribbon.rotation.x = 0.6;

                ribbonGeom.computeVertexNormals();
            }

        })
    </script>
</body>

</html>
